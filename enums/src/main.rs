#[derive(Debug)]
enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}
/* 
В отличии от структуры перечисление создается для определения свойств обьекта
как: Либо так, либо так.
Создавая перечисление мы задаем свойства, в данном примере задается ip адрес
он либо v4 либо v6 и принадлежит обьекту перечисление
*/
enum Message {
    Quit,
    Move {x: i32, y: i32},
    Write(String),
    ChangeColor(i32, i32, i32)
}
/*
    В данном месте становится понятно различие между структурами и перечислениями:
    1) Структура ропределяется под определенный тип данных например
        struct Rectangle {
            width: u32,
            height: u32,
        }
    будет принимать только два значения типа u32 характерных для прямоугольника, однако
    описать в этой структуре треугольник не возможно. В перечислении же можно создать несколько типов, например
        enum Figures {
            Line(i32, i32),
            Rectangle {width: u32, height: u32},
            Circle {radius: u32}
            ...
        }
    таким образом перечисление может обрабатывать множество данных сопоставляя их типы с перечисленными вариантами
*/
impl Message {
    fn call(&self) {}
}
#[derive(Debug)]
enum UnState {
    Alabama,
    Alaska,    
}
#[derive(Debug)]
enum Coin {
    Penny, 
    Nickel,
    Dime,
    Quarter(UnState),
}
//Перечисление использующее в качестве параметра одного из воих полей другое перечисление
//Полезно для параметризации входных данных
fn main() {
    // Экземпляры перечисления
    let home = IpAddr::V4(127, 0, 0, 1);
    let loopback = IpAddr::V6(String::from("::1"));

    let m = Message::Write(String::from("Message"));
    m.call();

    value_in_cents(Coin::Quarter(UnState::Alaska));

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("five: {:?} six: {:?} none: {:?}", five, six, none);

    let dice_roll = 9;
    match dice_roll {
        3 => add_fancy_hat(),
        7 => remove_fancy_hat(),
        _ => reroll(),//_ => (), - '_' - универсальный шаблон обозначающий ветку, которая обрабатывает данные не подходящие под критерии других веток
    }
    //Использование match для создания ветвления по типу Значение1 => Результат1 ... Что-то другое => Результат1 или Ничего не делать

}

fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => {
            println!("State quarter from state: {:?}", state);
            25
        }
    }
}

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}
//Использование match с шаблоном Option<T> по типу вернуть None или провести операцию если сходится по типу

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn reroll() {}

/*
    Итоги главы:
    1) Структуры можно использовать если есть строго типизированные данные, с которыми структура может работать
        Структура может иметь методы обработки полей своих экземпляров
    2) Перечисление используется в случае если входные данные могут быть нескольких типов
        Если обрабатывать такие данные структурами, то это приведет к созданию сложной структуры или нескольких маленьких
        что приведет к сложности кода
        Перечисления могут использовать в качестве параметра своих полей другие перечисления, что позваоляет
        создать глубокую структуру типизации данных
    3) Перечисления Option<T> позволяют создать строгую функцию кторая либо возвращает значение (Some) либо возвращает ничего (None)
    4) match перечисление полезно если есть несколько видов данных, которые должны порождать определенное действие и "остальные", 
        которые должны порождать одно единственное. Использование "_ => func() or ()," шаблона позволяет задать либо действие
        в случае получения данных некорректных для верхних веток, либо ничего не делать.
*/