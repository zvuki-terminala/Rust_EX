fn main() {
    /*
        У каждого значения в Rust есть владелец,
        У значения может быть только один владелец в один момент времени,
        Когда владелец покидает область видимости, значение удаляется.
    */
    // println!("{s}"); В этом месте переменная недоступна
    let s = "hello";
    println!("{s}");

    let mut s2 = String::from("Hello");
    s2.push_str(", world");
    println!("{}", s2);

    let s3 = String::from("hello");
    let s4 = s3;
    /* 
        println!("{}", s3); s3 переменная более недоступна т.к. ее область видимости
        окончилась на приравнивании ее значения s4 (автоматическое копирование перемещает 
        значение переменной из одного места в куче в другое)
    */
    println!("{}", s4);

    let s5 = String::from("Hello");
    let s6 = s5.clone();
    println!("s5 = {}, s6 = {}", s5, s6);
    /*
        clone() функция проводит глубокое копирование переменной копируя значение переменной в куче в другую
        переменную кучи
        т.о. обе переменные становятся доступными в своей области видимости
    */

    //Операции верхнего кода относятся к сложным типам данных неопределенной длинны, значения которых хранятся в куче

    let x = 5;
    let y = x;
    println!("x = {}, y = {}", x, y);
    /*
        Стековые данные хранят свои значения в стеке на все время выполнения области видимости,
        дополнительно они имеют т.н. типаж Copy, который автоматически проводит операцию копирования данных 
        между переменными в стеке
        Типы данных обладающие типажом Copy: целочисленные(u32 i32 ...), логические, типы с плавающей запятой(f32 ...), символьные (char)
        кортежи и т.д.
    */
}
