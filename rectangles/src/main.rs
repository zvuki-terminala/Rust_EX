#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}
/*
    Реализация метода rectangle:
    Внутри создается функция в качестве параметра которой выступает ссылка на
    структуру реализацией которой является метод, по сути само на себя
    указывая &self вместо self мы ограничиваем владение переменными для эхтого метода
    что важно учитывать для переменныых - должны ли они быть во владении кого либо еще
    в любом случае если передавыать права владения не нужно можно использовать ссылку на обьект
    */
impl Rectangle {
    fn area2(&self) -> u32 {
        self.width * self.height
    }
    /* 
        Функция сравнения длины и ширины прямоугольников - основы построения метода:
        1) Описываем в блоке внизу как должен выглядеть вызов метода относительно экземпляра:
            Мы получаем rectN.can_hold(&rectN)
                        ^^^              ^^^
                    Первый параметр    Второй параметр
            Первый параметр - ссылка на экземпляр структуры - в функции описывается как &self
            Второй параметр - ссылка на другой экземпляр структуры - т.к. все экземпляры
            по умолчанию нахродятся во владении Rectangle, а нам нужно только читать значения
            указываем параметр как other: &Recatangle - переменная значение которой является
            ссылка на вызываемый экземпляр принадлежащий структуре Rectangle
    */
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height:45,
    };
    /* 
        println!("rect1 is {:?}", rect1); Вывести значения структуры можно используя
        внешний втрибут #[derive(Debug)] 
    */

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );
    /* 
        Использование вышеописанного метода - указываем 
        экземпляр структуры и от его имени вызываем функцию 
        описанную в методе ссылающимся на одноименную структуру
    */
    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area2()
    );

    println!("Can rect1 hold rect2? {}", rect1.can_hold(&rect2));
    println!("Can rect1 hold rect3? {}", rect1.can_hold(&rect3));
}

fn area(rectangle: &Rectangle) -> u32 {
    rectangle.width * rectangle.height
}
/*
    Обьявив структуру передаем значения полям, передав в функцию ссылку
    на экземпляр мы расширяем область видимости полей для обработки внешней функцией
    Но можно сделать лучше создав метод вызывающийся в контексте структуры
*/